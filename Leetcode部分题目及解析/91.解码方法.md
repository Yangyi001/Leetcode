**题目难度：中等**  
一条包含字母 A-Z 的消息通过以下方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:
```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

示例 2:
```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/decode-ways
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

**解题思路**  
方法 1  
递归法解决
对于示例 2来说，给定编码为226，若不看最后一个字符6，对于22来说，若我们能求出对于22的解码有n种可能，那在这n种可能的基础上，加一个字符6在待解码的字符串22后面，只是在解码所得串后面加上字符F而已，解码方法依旧只有n种。  
继续分析，对于6来说，若其前面一个字符如果是1或者2的话，那么它就可以构成16、26，所以我们还需再往前看一个字符，对于示例 2来说，6前面的字符是2，构成了26，若这个时候我们能求出26其前面的字符串解码方式有k种，那在这k种可能的基础上加上字符26，相当于在解码所得串后面加上字符Z而已，解码方法依旧只有k种。  
所以总的解码个数就是n+k。对于示例 2的解码方式按此方法分析为2+1=3种。  

方法 2  
思路和方法1 类似，排除特殊情况后，解决过程如下
1. 若当前元素不为0，则当前解码方法==前面子串的解码方法
2. 若当前元素与其前一个元素所构成的字符范围在（10，26）之间，则还需加上除去当前元素及其前一个元素后，前面子串的解码方法  

**Python实现**  
方法 1
```
class Solution:
    def numDecodings(self, s: str) -> int:
    	# 递归终止条件：若字符数少于1，则只有一种解码情况
        if len(s) <= 1:
            return 1

		# 统计解码方法
        count = 0

		# 取出当前元素及当前元素的前一个元素
        curr = s[-1]
        prev = s[-2]

		# 若当前元素不为0，解码方法与前面n-1个元素解码方法相同
        if not curr == '0':
            count = self.numDecodings(s[:-1])

		# 若当前元素与其前一个元素构成的数字在10~26以内，则解码方法还需加上前面n-2个元素的解码方法
        if prev == '1' or (prev == '2' and curr <= '6'):
            count += self.numDecodings(s[:-2])
          
        # 返回总的解码方法
        return count
```
方法 2
```
class Solution:
    def numDecodings(self, s: str) -> int:
        if s == '' or s[0] == '0':
            return 0
        counter = [1,1]
        for i in range(1, len(s)):
            counter.append(0)
            if s[i] != '0':
                counter[i+1] = counter[i]
            if ('1' == s[i-1]) or ('2' == s[i-1] and '0' <= s[i] <= '6'):
                counter[i+1] += counter[i-1]
        return counter[-1]
```